
## Держим соединение сервисов по Websocket на Golang
В прошлой части мы создавали соединение между двумя Го программами. Теперь же хочу представить как держать соединение. А так же сделать команды для проверки статуса соединения, обрыва, восстановление, а так же попытки восстановить при обрыве связи транспортом Websocket.

1. Сделаем роутинг для создания соединения, для большей практичности будем в сообщении передавать адрес сервера.
- **check status websocket golang**  
 [How to check if a connection was closed without error?](https://github.com/gorilla/websocket/issues/104)  
`- Как правильно проверить, является ли ошибка нормальным состоянием (перезагрузка / закрытие вкладки, переход, явный ws.close ()) в отличие от состояния ошибки (сбой соединения, неправильный протокол, проблема SSL и т. Д.)?`  
`- Большинство приложений не вызывают close () на клиенте или вызывают close () только в ответ на ошибку соединения. Этим приложениям не нужно отличать ошибки, перечисленные в проблеме, от сетевой ошибки.`  
`- В данном примере не будем проверить случай, когда клиент явно вызвал close (), используйте`

2. Проверка, что Websocket соединение живое Go
- Состояние соединения  
Из [статьи js мира](https://learn.javascript.ru/websocket). - Чтобы получить состояние соединения, существует дополнительное свойство socket.readyState со значениями  
- **readystate websocket golang**  
[How to keep a websocket connection in OPEN readystate after send?](https://stackoverflow.com/questions/40710545/how-to-keep-a-websocket-connection-in-open-readystate-after-send)
- **ping pong message websocket**  
`- Протокол Websocket реализует так называемые сообщения PING / PONG. Сервер отправляет клиенту сообщение PING через Websocket, которое затем отвечает PONG. Если клиент не отвечает, сервер закрывает соединение.`  
Больше примеров на [официальном Github Gorilla](https://github.com/gorilla/websocket/blob/master/conn_test.go)
- **gorilla pinghandler**  
`- Читатель может заблокироваться, когда обработчик ping по умолчанию пишет pong`

Диагностирование. Если ***c.ReadMessage()*** вернет ошибку, значит нет соединения
```go
	mt, message, err := c.ReadMessage()
		if err != nil {
			log.Println("read:", err)
			break
		}
```

Два файла, это как две отдельных программы. В каждой из нах поднят свой HTTP сервис.
Программе client.go будем отправлять сообщение с помощью POST запроса, а server.go будет раболтать только по ws протоколу, он примет сообщение и отправит его обратно. На этом все завершится.

- server.go  
Этот файл мы представляем как некий "сервис", который должен где то крутиться, а мы к нему подключаемся.

- client.go  
Эту часть можно убрать куда нибудь в аркестратор, через него и будем отправлять команды.

Команда:
```sh
curl -H "Content-Type: application/json" -X POST http://localhost:7456/sh -d "Hello World"
```

## Теги
Вэбсокеты для Го самая эффективная связка, Websocker go example, ws golang start, ws go and go, общение Го сервисов по протоколу Websocket, go websocket client, websocket server


# Chat Gorilla
Запустили чат. Он работает в браузере, но поскольку мы будем делать тоже самое без браузера, то сделаем так, что бы он печатал сообщения.  
```sh
C:\Users\Tester\Projects\websocket-master\examples\chat>go run .
2020/11/15 20:05:07 /
2020/11/15 20:05:11 msg:fdg
```
Отлично! Реализуем отправителя.

По всей аидимости нужно реализовать не только отправителя, но и ридер, для более менее рабочего аида.