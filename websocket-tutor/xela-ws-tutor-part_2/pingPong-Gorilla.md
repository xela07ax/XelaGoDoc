### Управляющее сообщение
[Оригинальная статья на Godoc](https://godoc.org/github.com/gorilla/websocket#hdr-Control_Messages)  
Протокол WebSocket определяет три типа управляющих сообщений: close, ping и pong. Вызовите методы connection WriteControl, WriteMessage или NextWriter для отправки управляющего сообщения одноранговому узлу.

Соединения обрабатывают полученные сообщения о закрытии, вызывая функцию обработчика set с помощью метода SetCloseHandler и возвращая *CloseError из NextReader, ReadMessage или метода чтения сообщений. Обработчик закрытия по умолчанию отправляет одноранговому узлу сообщение о закрытии.

Соединения обрабатывают полученные сообщения ping, вызывая функцию обработчика, установленную с помощью метода SetPingHandler. Обработчик ping по умолчанию отправляет одноранговому узлу сообщение pong.

Соединения обрабатывают полученные сообщения pong, вызывая функцию обработчика set с помощью метода SetPongHandler. Обработчик pong по умолчанию ничего не делает. Если приложение отправляет сообщения ping, то приложение должно установить обработчик pong для получения соответствующего pong.

Функции обработчика управляющих сообщений вызываются из методов чтения NextReader, ReadMessage и message reader. Обработчики close и ping по умолчанию могут блокировать эти методы на короткое время, когда обработчик записывает данные в соединение.

Программа должна считывать подключение к процессу близко, пинг-понг и сообщения, отправленные от сверстников. Если приложение иным образом не заинтересовано в сообщениях от однорангового узла, то приложение должно запустить goroutine для чтения и отбрасывания сообщений от однорангового узла. Простой пример:
```go
func readLoop(c *websocket.Conn) {
    for {
        if _, _, err := c.NextReader(); err != nil {
            c.Close()
            break
        }
    }
}
```

